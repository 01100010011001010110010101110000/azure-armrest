module Azure
  module Armrest
    # Base class for managing templates and deployments
    class TemplateDeploymentService < ResourceGroupBasedService

      def initialize(configuration, options = {})
        super(configuration, 'deployments', 'Microsoft.Resources', options)
      end

      # Get names of all deployments in a resource group
      def list_names(resource_group = configuration.resource_group)
        list(resource_group).map(&:name)
      end

      # Get all deployments for the current subscription
      def list_all
        list_in_all_groups
      end

      # Get all operations of a deployment in a resource group
      def list_deployment_operations(deploy_name, resource_group = configuration.resource_group)
        validate_resource_group(resource_group)
        validate_resource(deploy_name)

        url = build_url(resource_group, deploy_name, 'operations')
        response = rest_get(url)
        JSON.parse(response)['value'].map { |hash| TemplateDeploymentOperation.new(hash) }
      end

      # Get the operation of a deployment in a resource group
      def get_deployment_operation(op_id, deploy_name, resource_group = configuration.resource_group)
        validate_resource_group(resource_group)
        validate_resource(deploy_name)
        raise ArgumentError, "must specify operation id" unless op_id

        url = build_url(resource_group, deploy_name, 'operations', op_id)
        response = rest_get(url)
        TemplateDeploymentOperation.new(response)
      end

      # Returns the json template as an object for the given deployment.
      #
      # If you want the plain JSON text then call .to_json on the returned object.
      #
      def get_template(deploy_name, resource_group = configuration.resource_group)
        validate_resource_group(resource_group)
        validate_resource(deploy_name)
        url = build_url(resource_group, deploy_name, 'exportTemplate')
        response = JSON.parse(rest_post(url))['template']
        DeploymentTemplate.new(response)
      end

      # Delete a deployment and all associated resources that were generated by the
      # deployment.
      #
      # This is a synchronous call. It waits until all deletions complete
      def delete_associated_resources(deploy_name, resource_group = configuration.resource_group)
        operations = list_deployment_operations(deploy_name, resource_group)
        resource_urls = operations.collect do |op|
          if op.properties.provisioning_operation =~ /^create$/i
            resource_id = op.properties.target_resource.id
            "#{configuration.resource_url}#{resource_id}?api-version=#{api_version}"
          end
        end.compact
        resource_urls << build_url(resource_group, deploy_name)

        delete_resources(resource_urls, resource_urls.size)
      end

      private

      def delete_resources(urls, retry_cnt)
        if retry_cnt == 0
          urls.each { |url| log("error", "Failed to delete #{url}") }
          return
        end

        remaining_urls = urls.collect { |url| delete_resource(url) }.compact
        delete_resources(remaining_urls, retry_cnt - 1) unless remaining_urls.empty?
      end

      def delete_resource(url)
        log("Deleting #{url}")
        response = rest_delete(url)
        headers = Azure::Armrest::ResponseHeaders.new(response.headers)
        headers.response_code = response.code
        return nil unless async_delete?(headers, url)

        wait(headers)

        log("Deleted #{url}")
        nil
      rescue Azure::Armrest::BadRequestException => err
        m = err.message.match(/The supported api-version.*?'(\d{4}-\d{2}-\d{2}(-preview)?)[',]/)
        return url.gsub(/\?api-version=(.*)/, "?api-version=#{m[1]}") if m

        log("debug", err.to_s)
        log("Resource #{url} cannot be deleted because of BadRequestException. Will try again.")
        url
      rescue Azure::Armrest::PreconditionFailedException, Azure::Armrest::ConflictException => err
        log("debug", err.to_s)
        log("Resource #{url} cannot be deleted because it is used by others. Will try again.")
        url
      end

      def async_delete?(headers, url)
        return false if [200, 201].include?(headers.response_code)
        if !headers.respond_to?(:azure_asyncoperationn) && !headers.respond_to?(:location)
          log("#{url} may have been deleted")
          return false
        end
        true
      end
    end
  end
end
